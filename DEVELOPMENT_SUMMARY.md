# Budget Manager - Development Summary

## Project Overview

Budget Manager is a comprehensive personal finance application built with .NET 8 and ASP.NET Core MVC. The application provides users with a complete solution for tracking income and expenses, managing monthly budgets, and generating financial reports. Key features include transaction management with full CRUD operations, category-based organization, multi-account support, budget pacing calculations that show "Safe to Spend Today" metrics, CSV import with duplicate detection and auto-categorization, and comprehensive reporting including budget vs actual comparisons and month-over-month trend analysis. The application also includes data protection features such as month locking to prevent accidental edits to finalized periods, adjustment transactions that bypass locks for corrections, and a complete activity log for audit trails.

The application follows a clean architecture pattern with separation of concerns: controllers handle HTTP requests, services contain business logic, and Entity Framework Core manages data access. Authentication is handled through ASP.NET Core Identity, and the UI is built with Bootstrap 5 for responsive design, Chart.js 4.4.1 for data visualization, and Google Charts for advanced Sankey diagrams. The application features a modern, polished user interface with gradient cards, animated visualizations, dark mode support, and interactive dashboards. The application was originally designed to use SQL Server as its database backend, which presented significant challenges during development on macOS systems.

## Development Challenges and Solutions

### Primary Challenge: Cross-Platform Database Compatibility

The most significant issue encountered during development was the application's dependency on SQL Server LocalDB, which is a Windows-only technology. When attempting to run the application on macOS, the connection string pointing to `(localdb)\mssqllocaldb` failed because LocalDB is not available on non-Windows platforms. This created a blocker that prevented the application from running in development environments on macOS and Linux systems.

The solution was to migrate the entire application from SQL Server to SQLite, a lightweight, file-based database engine that works seamlessly across all platforms. This migration involved several interconnected changes: updating the NuGet package reference from `Microsoft.EntityFrameworkCore.SqlServer` to `Microsoft.EntityFrameworkCore.Sqlite`, modifying the connection strings in both `appsettings.json` and `appsettings.Development.json` to use SQLite's file-based format (`Data Source=BudgetManager.db`), and changing the database provider configuration in `Program.cs` from `UseSqlServer()` to `UseSqlite()`. Additionally, the Entity Framework Core migrations had to be completely rewritten because SQLite uses different data types and syntax than SQL Serverâ€”for example, SQLite uses `INTEGER` for auto-incrementing primary keys and `TEXT` for strings, whereas SQL Server uses `int` with identity columns and `nvarchar`. The migration files were regenerated to use SQLite-compatible SQL, and a missing Designer file was created to ensure Entity Framework Core could properly track and apply migrations.

### Secondary Challenge: LINQ Translation Limitations

After successfully migrating to SQLite, a critical runtime error emerged when the application attempted to execute queries that used `Math.Abs()` in LINQ expressions. SQLite's Entity Framework Core provider cannot translate `Math.Abs()` into SQL, resulting in an `InvalidOperationException` with the message "Translation of method 'System.Math.Abs' failed." This error occurred in multiple locations throughout the codebase, including the budget service that calculates spending summaries, transaction service methods that filter and aggregate expenses, and various controllers that display financial data.

The solution required a systematic refactoring of all database queries that used `Math.Abs()`. Since the application stores expenses as negative values and income as positive values, we replaced all instances of `Math.Abs(t.Amount)` with `-t.Amount` (negation) when working with expense transactions. This approach works because expenses are already negative, so negating them produces the same result as taking the absolute value, and SQLite can translate simple arithmetic operations. The changes were made across seven files: `BudgetService.cs`, `TransactionService.cs`, `HomeController.cs`, `CategoriesController.cs`, `BudgetsController.cs`, `LockMonthController.cs`, and `ReportsController.cs`. In some cases, such as filtering by amount ranges, we had to rewrite the logic to check both positive and negative values explicitly (e.g., `t.Amount >= minVal || t.Amount <= -minVal`) instead of using absolute value comparisons.

### UI/UX Enhancement: Modern Visual Design and Interactive Dashboards

A significant enhancement phase focused on transforming the application's user interface from a functional but basic design to a modern, visually impressive experience. The dashboard was redesigned with gradient summary cards featuring smooth hover animations and lift effects, replacing flat Bootstrap cards. An animated donut chart replaced the horizontal bar chart for category spending, featuring smooth rotation animations, gradient fills, and a center display showing total spending. A dark mode toggle was implemented with CSS custom properties (CSS variables) for seamless theme switching, persisting user preferences in localStorage and updating all components including charts, tables, and forms. Number counter animations were added to summary cards, using easing functions to count up from zero to final values when scrolled into view, creating an engaging user experience.

The Sankey diagram for cash flow visualization initially encountered rendering issues with negative height errors due to too many nodes (categories plus individual merchants). The solution involved simplifying the data structure to show only the top 6 categories plus an "Other" category and savings, reducing the node count from 20+ to approximately 8 nodes. Fixed dimensions (500x320px) were implemented instead of dynamic calculations that were returning invalid values, and node padding was optimized to ensure proper rendering within the available space.

### Additional Technical Adjustments

Several other technical adjustments were necessary to complete the migration and enhancements. The `ApplicationDbContext` configuration had to be updated to use `HasConversion<double>()` for decimal properties because SQLite stores decimals as `REAL` (double-precision floating point) rather than the `decimal(18,2)` type used by SQL Server. The `LockingService` was refactored to remove a SQL Server-specific stored procedure call (`sp_LockMonth`) and instead use pure Entity Framework Core operations, which are database-agnostic. The `.gitignore` file was updated to exclude SQLite database files (`*.db`, `*.db-shm`, `*.db-wal`) from version control, as these are local development artifacts that should not be committed.

For the UI enhancements, custom CSS was created with CSS variables for theme support, enabling dynamic color switching between light and dark modes. JavaScript utilities were added for animated counters using Intersection Observer API for scroll-triggered animations, and Chart.js configurations were updated to support theme-aware colors. The Inter font family was integrated for modern typography, and comprehensive hover effects, transitions, and micro-interactions were added throughout the interface.

## Outcome

The migration to SQLite was successful, and the application now runs seamlessly on macOS, Windows, and Linux platforms without requiring any database server installation. The application maintains all its original functionality while being more accessible to developers working on different operating systems. The SQLite database file is created automatically on first run, migrations are applied automatically through the seed data initialization process, and the application includes demo data (a demo user account, default categories, sample accounts, and pre-configured categorization rules) to help new users get started quickly.

The UI/UX enhancements have transformed the application into a modern, polished financial management tool with engaging visualizations, smooth animations, and a professional appearance. The dark mode feature improves usability in low-light environments, and the animated counters and interactive charts create a more engaging user experience. The application is now truly cross-platform, visually impressive, and ready for development and deployment across all major operating systems.

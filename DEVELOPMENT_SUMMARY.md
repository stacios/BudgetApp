# Budget Manager - Development Summary

## Project Overview

Budget Manager is a comprehensive personal finance application built with .NET 8 and ASP.NET Core MVC. The application provides users with a complete solution for tracking income and expenses, managing monthly budgets, and generating financial reports. Key features include transaction management with full CRUD operations, category-based organization, multi-account support, budget pacing calculations that show "Safe to Spend Today" metrics, CSV import with duplicate detection and auto-categorization, and comprehensive reporting including budget vs actual comparisons and month-over-month trend analysis. The application also includes data protection features such as month locking to prevent accidental edits to finalized periods, adjustment transactions that bypass locks for corrections, and a complete activity log for audit trails.

The application follows a clean architecture pattern with separation of concerns: controllers handle HTTP requests, services contain business logic, and Entity Framework Core manages data access. Authentication is handled through ASP.NET Core Identity, and the UI is built with Bootstrap 5 for responsive design and Chart.js for data visualization. The application was originally designed to use SQL Server as its database backend, which presented significant challenges during development on macOS systems.

## Development Challenges and Solutions

### Primary Challenge: Cross-Platform Database Compatibility

The most significant issue encountered during development was the application's dependency on SQL Server LocalDB, which is a Windows-only technology. When attempting to run the application on macOS, the connection string pointing to `(localdb)\mssqllocaldb` failed because LocalDB is not available on non-Windows platforms. This created a blocker that prevented the application from running in development environments on macOS and Linux systems.

The solution was to migrate the entire application from SQL Server to SQLite, a lightweight, file-based database engine that works seamlessly across all platforms. This migration involved several interconnected changes: updating the NuGet package reference from `Microsoft.EntityFrameworkCore.SqlServer` to `Microsoft.EntityFrameworkCore.Sqlite`, modifying the connection strings in both `appsettings.json` and `appsettings.Development.json` to use SQLite's file-based format (`Data Source=BudgetManager.db`), and changing the database provider configuration in `Program.cs` from `UseSqlServer()` to `UseSqlite()`. Additionally, the Entity Framework Core migrations had to be completely rewritten because SQLite uses different data types and syntax than SQL Serverâ€”for example, SQLite uses `INTEGER` for auto-incrementing primary keys and `TEXT` for strings, whereas SQL Server uses `int` with identity columns and `nvarchar`. The migration files were regenerated to use SQLite-compatible SQL, and a missing Designer file was created to ensure Entity Framework Core could properly track and apply migrations.

### Secondary Challenge: LINQ Translation Limitations

After successfully migrating to SQLite, a critical runtime error emerged when the application attempted to execute queries that used `Math.Abs()` in LINQ expressions. SQLite's Entity Framework Core provider cannot translate `Math.Abs()` into SQL, resulting in an `InvalidOperationException` with the message "Translation of method 'System.Math.Abs' failed." This error occurred in multiple locations throughout the codebase, including the budget service that calculates spending summaries, transaction service methods that filter and aggregate expenses, and various controllers that display financial data.

The solution required a systematic refactoring of all database queries that used `Math.Abs()`. Since the application stores expenses as negative values and income as positive values, we replaced all instances of `Math.Abs(t.Amount)` with `-t.Amount` (negation) when working with expense transactions. This approach works because expenses are already negative, so negating them produces the same result as taking the absolute value, and SQLite can translate simple arithmetic operations. The changes were made across seven files: `BudgetService.cs`, `TransactionService.cs`, `HomeController.cs`, `CategoriesController.cs`, `BudgetsController.cs`, `LockMonthController.cs`, and `ReportsController.cs`. In some cases, such as filtering by amount ranges, we had to rewrite the logic to check both positive and negative values explicitly (e.g., `t.Amount >= minVal || t.Amount <= -minVal`) instead of using absolute value comparisons.

### Additional Technical Adjustments

Several other technical adjustments were necessary to complete the migration. The `ApplicationDbContext` configuration had to be updated to use `HasConversion<double>()` for decimal properties because SQLite stores decimals as `REAL` (double-precision floating point) rather than the `decimal(18,2)` type used by SQL Server. The `LockingService` was refactored to remove a SQL Server-specific stored procedure call (`sp_LockMonth`) and instead use pure Entity Framework Core operations, which are database-agnostic. Finally, the `.gitignore` file was updated to exclude SQLite database files (`*.db`, `*.db-shm`, `*.db-wal`) from version control, as these are local development artifacts that should not be committed.

## Outcome

The migration to SQLite was successful, and the application now runs seamlessly on macOS, Windows, and Linux platforms without requiring any database server installation. The application maintains all its original functionality while being more accessible to developers working on different operating systems. The SQLite database file is created automatically on first run, migrations are applied automatically through the seed data initialization process, and the application includes demo data (a demo user account, default categories, sample accounts, and pre-configured categorization rules) to help new users get started quickly. The application is now truly cross-platform and ready for development and deployment across all major operating systems.
